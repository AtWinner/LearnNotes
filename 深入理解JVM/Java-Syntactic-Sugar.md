几乎各种语言都会或多或少的提供一些语法糖来方便程序员的代码开发，这些语法糖虽然不会提供实质性的功能改进，但是他们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。不过也有一种观点认为语法糖并不一定是有益的，大量添加和使用语法糖，容易让程序员产生依赖，无法看清语法糖的糖衣背后，程序代码的真正面目。
## 泛型和类型擦除
泛型是在JDK1.5的一项新增特性，它的本质是参数化的类型的应用，也就是说所操作的数据类型指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。

泛型思想早在C++语言的模板中就开始萌芽，在Java语言处于还没有出现泛型版本时，只能通过Object是所有类型的父类和类型强制转换两个特点来配合实现类型泛化。例如，在哈希表的存取中，JDK1.5之前使用HashMap的get方法，返回值就是一个Object对象，由于Java语言里面所有的类型都继承与java.lang.Object，所以Object转型成任何对象都是有可能的。但是也因为有无限种可能，就只有程序员和运行期的虚拟机才知道Object到底是什么对象。在编译期间，编译器无法检查到这个Object的强制类型转换是否成功，如果仅仅依赖程序员去保障这项操作的正确性的话，会有许多ClassCastException的风险转嫁到程序运行期间。

泛型在Java和C#中的使用方式看似相同，但实际上却有着根本性的分歧。C#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，List<int>与List<String>就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。

Java中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换成原来的原生类型了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList<Integer>和ArrayList<String>就是同一个类型，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。
