> Java和C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进来，墙里面的人想出来。

# 对象已死吗
在堆里放着的Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。

## 引用计数法
客观的讲，引用计数法的实现简单，判定效率也很高，在大多数情况下它都是一个不错的算法，也有一些比较著名的案例，例如微软的COM（Component Object Model）技术、使用ActionScript3的FlashPlayer、Python语言等都使用了引用计数算法来进行内存管理。但是，**至少在主流的JVM中没有选用引用计数算法来管理内存**，其中最主要的原因是它很难解决对象之间相互引用的问题。

## 可达性分析算法
在主流的商用程序语言（Java、C#等）的主流实现中，都是称通过可达性分析来判断对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些细节开始向下搜索，搜索所走过的路径成为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连的时候，用图论的话来说，就是从GC Roots到这个对象不可达的时候，则证明此对象是不可用的。

在Java语言中，可作为GC Roots的对象包括下面几种：
- 虚拟机栈（栈帧中本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象。

## 再谈引用
无论是通过引用技术算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判断对象是否存活都与“引用”有关。在JDK1.2之前，Java中的引用定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述“食之无味，弃之可惜”的鸡肋对象就显得无能为力了。

在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用，这4种引用强度依次逐步减弱。
- 强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出OOM。在JDK1.2之后，提供了SoftReference来实现软引用。
- 弱引用也可以用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference来实现弱引用。
- 虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存周期构成影响，也无法通过虚引用来取的一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference来实现虚引用。

## 生存还是死亡
即使在可达性分析算法中不可达的对象，也并非是非死不可的，这个时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经理两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且运行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机吊用过，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会防止在一个叫F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，或者更极端的情况，将很有可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GV将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，比如把自己（this）赋值给某个类变量或者对象的成员变量，那再第二次标记时它将被移除出“即将回收”的集合：如果对象这个时候还没有逃脱，那基本上他就真的被回收了。 

## 回收方法区
很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，JVM规范中确定说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的性价比一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的来及收集效率远低于此。

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，加入一个字符串“abc”已经进入了常量池，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与类似。

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是无用的类的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是无用的类：
- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是可以，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassbc参数进行控制。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

# 垃圾收集算法
由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，因此本节不打算过多讨论算法的实现，只是介绍几种算法的思想及其发展过程。

## 标记-清除算法
最基础的收集算法是“标记-清除”算法，如同他的名字一样，算法分为“标记”和“清除”两个阶段： 首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的不足：一是效率问题，标记和清除两个过程的效率并不高；另一个是控件问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

## 复制算法
为了解决效率问题，一种称为复制的收集算法出现了，它将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用光了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。

现在的商业虚拟机都采用了这种收集算法来回收新生代，IBM公司的专门研究表明，新生代的对象98%是朝生夕死的，并不需要按照1:1的比例来划分内存空间，而是将内存分为较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性的复制到哦另一款Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor的空间不够用时，需要依赖其他内存（这里指的是老年代）进行分配担保。

## 标记-整理算法
复制收集算法在对象存活率较高时要进行较多的复制操作，效率就会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代不能直接用这种算法。

根据老年代的特点，有人提出了“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的UI小向一端移动，然后直接清理掉端便捷意外的内存。

# HotSpot的算法实现
在HotSpot虚拟机上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。

## 枚举根节点
从可达性分析中从GCRoots节点找引用链这个操作为例，可作为GCRoots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百M，如果要逐个检查这里面的引用，那么必然会消耗很多时间。

另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行，这里的一致性是指在整个分析期间整个执行系统看起来就像冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保障。这点是导致GC进行时必须挺多所有Java执行线程的其中一个重要原因，Sun将这件事成为“Stop The World”，即使是在号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

由于目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组成为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。

## 安全点
在OopMap的协助下，HotSpot可以快速且准确的完成GCRoots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。

实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在特定的位置记录了这些信息，这些位置成为安全点，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待的时间太长，也不能过于频繁以致于过分增加运行时的负荷。所以安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，具有这些功能的指令才会产生安全点。

对于Safepoint，另一个需要考虑的问题就是如何在GC发生时让所有线程（不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供算则：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。
- 其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。现在几乎没有虚拟机实现才有抢先式中断来暂停线程从而响应GC。
- 而主动式中断的思想是当GC需要中断线索的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行主动去轮训这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

## 安全区域
使用Safepoint似乎已经完美的解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序不执行的时候呢？所谓程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这个时候线程无法响应JVM的中断请求，走到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域来解决。

安全区域是指一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把SafeRegion看做是被扩展的Safepoint。

在线程执行到Safe Region中的代码时，首先标识自己已经进入了SafeRegion，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为SafeRegion状态的线程了。在线程要离开SafeRegion时，它要检查系统是否已经完成了根节点枚举，或者整个GC过程，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开SafeRegion的信号为止。

# 垃圾收集器
> 因为内存回收如何进行是由虚拟机所采用的GC收集器决定的，而通常虚拟机中往往不止有一种GC收集器。

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK1.7 Update14之后的HotSpot虚拟机，在这个版本中正式提供了商用的G1收集器，这个虚拟机包含的所有收集器如下

![HotSpot虚拟机垃圾收集器](http://oi9a3yd8k.bkt.clouddn.com/HotSpot-JVM-GC.png)

图中展示了7种不同分代的收集器，如果两个收集器之间存在连线，就说明他们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代还是老年代的收集器。我们虽然要对各个收集器进行比较，但是并非为了选择一种最好的收集器。因为知道现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的知识因轨道具体应用场景下最合适的收集器。

## Serial收集器
Serial收集器是最基本、发展历史最悠久的收集器，在JDK1.3.1之前是虚拟机新生代收集的唯一选择。看名字就知道，这个收集器是一个单线程的收集器，但它的单线程的意义并不仅仅说明它使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，知道它收集结束。“Stop the World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。图中示意了Serial/Serial Old收集器的运行过程。

![Serial/Serial Old收集器运行示意图](http://oi9a3yd8k.bkt.clouddn.com/Serial-SerialOld.png)

从JDK1.3开始，一直到现在最新的JDK1.7，HotSpot虚拟机开发团队为清除或者减少工作线程银内存回收而导致停顿的努力一直在进行着，从Serial收集器到Parallel收集器，再到CMS乃至GC收集器的最前沿成果G1收集器，我们看到了一个个越来越优秀的收集器出现，用户线程的收集时间不断缩短，但是仍然没有完全消除。

它依然是虚拟机运行在Client模式下默认新生代的收集器。它有着优于其他收集器的地方：
- 与其他收集器的单线程比，它简单高效
- 对于限定单个CPU的环境来说，优于没有线程交互的开销，专心做垃圾收集，因此获得最高的单线程收集效率

在用户的桌面应用场景，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至几百兆的新生代，停顿时间完全可以控制在几十毫秒以内，只要不频繁发生，这点停顿还是可以接受的。所以Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。

## ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop the World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两个收集器也公用了相当多的代码。
![PerNew/Serial Old收集器运行示意图](http://oi9a3yd8k.bkt.clouddn.com/pernew.png)
ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是很多运行在Server模式下虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK1.5时期，HotSpot推出了一款在强交互中几乎可任务有划时代意义的垃圾收集器，CMS收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。

不幸的是，CMS作为老年代的收集器，无法与JDK1.4.0中存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来手机老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器也是使用-XX:UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:UsePerNewGC来强制指定它。

PerNew收集器在单CPU的环境中绝对不会比Serial收集器的效果更好，甚至优于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证可以超越Serial收集器。当然，随着可以使用的CPU的数量越来越多，它对于GC时系统资源的有效利用还是会很有好处的。它默认开启的线程数量与CPU的数量相同，在CPU非常多的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。

> 并发和并行
> - 并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
> - 并发(Concurrent)：指用户线程与垃圾收集线程同时执行，但不一定是并行的，可能会交替执行，用户程序在继续运行，而垃圾收集程序云星宇另一个CPU上。

## Parallel Scavenge收集器
Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和PerNew都一样，那它有什么特别之处？

Parallel Scavenge收集器的特点是它的关注点和其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间÷（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，吞吐量就是99%。

停顿的时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis阐述一斤直接设置吞吐量大小的-XX:GCTimeRatio参数。

- MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收话费的时间不超过设定值。不过不要认为如果把这个参数的值设置的小一点就能使得系统的垃圾收集速度变快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快，这也直接导致垃圾收集发生得更频繁一些，原来10s收集一次、每次停顿100ms，现在变成5s手机一次、每次停顿70ms。停顿时间确实是在下降，但吞吐量也在下降。
- GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设为19，那允许的最大GC时间就占总时间的5%，即1÷(1+19)，默认值是99%，就是允许最大1%，即1÷(1+99)的垃圾收集时间。

由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称为吞吐量优先收集器。除了上述两个参数外，Parallel Scavenge收集器还有一个参数-XX:UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小、Eden与Survivor去的比例、晋升老年代对象大小等细节参数，虚拟机会根据当前系统的运行状况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式成为GC自适应的调节策略。

## Serial Old收集器
Serial Old收集器是Serial收集器的老年版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Clinet模式下的虚拟机使用。如果在Server模式下，它主要还有两大用途：
- 一种是在JDK1.5的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后背预案，在并发手机发生Concurrent Mode Failure时使用。工作流程如下。

![Serial/Serial Old收集器运行示意图](http://oi9a3yd8k.bkt.clouddn.com/Serial-SerialOld.png)
## Parallel Old收集器
Parallel Old是 Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old收集器外别无选择。由于老年代Serial Old收集器在服务端应用性能上的拖累，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至不一定有ParNew+CMS的组合好。

直到Parallel Old收集器的出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old收集器。

![Parallel Scavenge/Parallel Old收集器运行示意图](http://oi9a3yd8k.bkt.clouddn.com/Parallel-Scavenge-Old.png)

## CMS 收集器
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿的时间最短，给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤：
- 初始标记(CMS initial mark)
- 并发标记(CMS concurrent mark)
- 重新标记(CMS remark)
- 并发清除(CMS concurrent sweep)

其中，初始标记、重新标记着两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，MCS收集器的内存回收过程是与用户线程一起并发执行的。
![Concurrent-Mark-Sweep收集器运行示意图](http://oi9a3yd8k.bkt.clouddn.com/Concurrent-Mark-Sweep.png)

CMS是一款优秀的收集器，它的主要优点在名字上应体现出来了：并发手机、低停顿，Sun公司的一些官方文档中也称之为并发低停顿收集器（Concurrent Low Pause Collector）。但是CMS还远没达到完美的程度，以为它有如下3个缺点：
- CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程或者CPU资源而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数量是（CPU数量+3）÷4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并随着CPU数量的增加而下降。但是当CPU不足4个的时候，CMS对用户程序的影响可能会变大，如果本来CPU负载就比较大，还要分出来一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低50%，其实也是令人无法接受的。
- CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次FullGC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为浮动垃圾。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在JDK1.5的默认设置下，CMS收集器与老年代使用了68%的控件后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingQccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK1.6中，CMS收集器的启动阈值已经提升到了92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时，虚拟机将启动后背预案：临时启用Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置的太高很容易导致大量“Concurrent Mode Failure”失败，性能反而会降低。
- 最后一个缺点，CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会产生大量的空间碎片，这将会给大对象分配带来很大的麻烦，往往会出现老年代还有扥大剩余空间，但是无法找到足够大的连续空间来分配给当前对象，不得不提前触发一次FullGC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认是开启的），用于CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者还提供了另一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩FullGC后，跟着来一次带压缩的，默认值是0，表示每次进入FullGC时都进行碎片整理。

## G1收集器
G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，早在JDK1.7刚刚确立项目目标，Sun公司给JDK1.7RoadMap里面，它就被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。从JDK6u14中开始就有Early Access版本的G1收集器供开发人员实验、试用，由此G1收集器的“Experimental”状态持续了数年时间，直至JDK7u4，Sun公司才认为它达到了足够成熟的商用程度，移除了“Experimental”标识。

G1收集器是一款面向服务端应用的垃圾收集器。HotSpot开发团队富裕它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备以下特点：
- 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU或者多核CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java核心线程的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。
- 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过了多次GC的旧对象以获取更好的收集效果。
- 空间整合：与CMS的“标记-清楚”算法不同，G1从整体上来看是基于“标记-整理”算法实现的收集器，从局部上来看是基于“复制”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存而提前触发下一次GC。
- 可预测的停顿：这里G1相对于CMS的另一大优势，降低停顿时间的G1和CMS共同关注点，但G1除了追求低停顿外，还能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎是实时Java（RTSJ）的垃圾收集器的特征了。

在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。

G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以获取尽可能高的收集效率。

如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下步骤：
- 初始标记（Initial Marking）
- 并发标记（Concurrent Marking）
- 最终标记（Final Marking）
- 筛选标记（Live Data Counting and Evacuation）

G1的前几个步骤的运作过程和CMS有很多相似之处。初始标记阶段仅仅只是标记一下GCRoots能直接关联到的对象，并且修改TAMS（Next Top At Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。并发标记阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set中，这阶段需要停顿线程，但是可并行执行。最后在筛选回首阶段首先对各个Region的回收价值和成本进行评估排序，根据用户所期望的GC停顿时间来制定回收计划。

![G1收集器运行示意图](http://oi9a3yd8k.bkt.clouddn.com/Garbage-First.png)

## 垃圾收集器常用参数总结
- **UseSerialGC**：虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收
- **UseParNewGC**：打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收
- **UseConcMarkSweepGC**：打开此开关后，使用ParNew+CMS+Serial Old的收集器组合内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用
- **UseParallelGC**：虚拟机在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old的收集器组合进行内存回收
- **UseParallelOldGC**：打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内回收
- **SurvivorRatio**：新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor=8:1
- **PretenureSizeTheshold**：直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接分配到老年代
- **MaxTenuringTheshold**：晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄都增加1，当超过这个参数值时就进入老年代
- **UseAdaptiveSizePolicy**：动态调整Java堆中各个区域的大小以及进入老年代的年龄
- **HandlePromotionFailure**：是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的左右对象都存活的极端情况
- **ParallelGCThreads**：设置并行GC时进行内存回收的线程数
- **GCTimeRatio**：GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅仅在使用Parallel Scavenge收集器时生效
- **MaxGCPauseMillis**：设置GC的最大停顿时间，仅在是使用Parallel Scavenge收集器时生效
- **CMSInitiatingOccupancyFraction**：设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值是68%。仅在使用CMS收集器时生效
- **UseCMSCompactAtFullCollection**：设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效
- **CMSFullGCsBeforeCompaction**：设置CMS收集器在进行若干次垃圾收集后再次启动一次内存碎片整理。仅在使用CMS收集器时生效