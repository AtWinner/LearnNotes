# 写在前面
View是Android在视觉上的呈现，在界面上Android提供了一套GUI库，里面有很多控件，除了View的三大流程以外，View常见的回调方法也是需要熟练掌握，比如构造方法、onAttach、onVisibilityChanged、onDetach等。另外对于一些具有滑动效果的自定义View和滑动冲突也需要处理。

# ViewRoot
ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联。

``` java
root = new ViewRootImpl(view.getContext(), display);
root.setView(view, wparams, panelParentView);
```

View的绘制流程是从ViewRoot的performTraversals方法开始的，它经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure用来测量View的宽和高，layout用来确定View在父容器中的放置位置，而draw则负责将View绘制在屏幕上。针对performTraversals的大致流程，可以用流程图表示
![performTraversals的大致流程](http://oi9a3yd8k.bkt.clouddn.com/performTraversals.png)

- performTraversals会一次调用performMeasure、performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程，其中在performMeasure中会调用measure方法，在measure方法中又会调用onMeasure方法，在onMeasure方法中则会对所有的子元素进行measure过程，这个时候measure流程就从父容器传递到子元素中了，这样就完成了一次measure过程。接着子元素会重复父容器的measure过程，如此反复就完成了整个View树的遍历。同理performLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是，performDraw的传递过程是在draw方法中通过dispatchDraw来实现的，不过这并没有什么不同。

- measure决定了View的宽高，Measure完成以后，可以通过getMeasureWidth和getMeasureHeight方法来获取到View测量后的宽高，在几乎所有的情况下它都等同于View的最终宽高，有些特殊情况下除外。Layout过程决定了View的四个顶点的坐标和实际的View的宽高，完成以后可以通过getTop、getBottom、getLeft、getRight来拿到View的四个顶点的位置，并可以通过getWidth和getHeight来获得View的最终宽高。Draw过程则决定了View的显示，只有draw方法完成以后View的内容才能呈现在屏幕上。

# DecorView

DecorView作为顶级View，一般情况下它内部会包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分，上面是标题栏，下面是内容栏。在Activity中我们通过setContentView所设置的布局文件其实就是被加载到内容栏中的，而内容栏的id就是content，因此可以理解为什么Activity指定布局的方法不叫setView而是叫setContentView，因为我们的布局的确加到了id为content的FrameLayout中。DecorView其实就是一个FrameLayout，View层的时间都先经过DecorView，然后才传递给我们的View